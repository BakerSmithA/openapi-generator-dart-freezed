{{#vendorExtensions.x-is-pure}}
{{! 
Can use _<classname>FromJson provided by freezed package, because when a 
discriminator is present, 
https://pub.dev/packages/freezed#fromjson---classes-with-multiple-constructors
}}
factory {{classname}}.fromJson(Map<String, dynamic> json) => _${{classname}}FromJson(json);
{{/vendorExtensions.x-is-pure}}

{{^vendorExtensions.x-is-pure}}
    {{^vendorExtensions.x-is-child}}
        {{! 
        If no mapping is provided in the API spec, we need to override 
        the default freezed behaviour, which will compare a "runtimeType"
        discriminator it expects on the JSON:
        https://pub.dev/packages/freezed#fromjson---classes-with-multiple-constructors

        Instead, we deserialise the JSON, and see whether it matches and of 
        our model classes.
        }}
        {{^hasDiscriminatorWithNonEmptyMapping}}
            factory {{classname}}.fromJson(Map<String, dynamic> json) {
                final fromJsonMethods = <FromJsonMethodType<dynamic>>[{{#anyOf}}{{#lambda.titlecase}}{{#PrimitiveFromJson}}{{{.}}}{{/PrimitiveFromJson}}{{/lambda.titlecase}}.fromJson,{{/anyOf}}{{#oneOf}}{{#lambda.titlecase}}{{#PrimitiveFromJson}}{{{.}}}{{/PrimitiveFromJson}}{{/lambda.titlecase}}.fromJson,{{/oneOf}}];
                final deserializedModels = <{{classname}}>[];
                {{classname}}? deserializedModel;
                for (final fromJsonMethod in fromJsonMethods) {
                    final dynamic parsedModel = fromJsonMethod.call(json);
                    // Note following line won't be executed if already the above parsing fails.
                    switch (deserializedModel.runtimeType) {
                        {{#anyOf}}
                            case {{#lambda.titlecase}}{{#PrimitiveInUnion}}{{{.}}}{{/PrimitiveInUnion}}{{/lambda.titlecase}}:
                                deserializedModel =  {{classname}}.as{{#lambda.titlecase}}{{#PrimitiveInUnion}}{{#lambda.camelcase}}{{{.}}}{{/lambda.camelcase}}{{/PrimitiveInUnion}}{{/lambda.titlecase}}(
                                    parsedModel as {{#lambda.titlecase}}{{#PrimitiveInUnion}}{{{.}}}{{/PrimitiveInUnion}}{{/lambda.titlecase}},
                                );
                                break;
                        {{/anyOf}}
                        {{#oneOf}}
                            case {{#lambda.titlecase}}{{#PrimitiveInUnion}}{{{.}}}{{/PrimitiveInUnion}}{{/lambda.titlecase}}:
                                deserializedModel =  {{classname}}.as{{#lambda.titlecase}}{{#PrimitiveInUnion}}{{#lambda.camelcase}}{{{.}}}{{/lambda.camelcase}}{{/PrimitiveInUnion}}{{/lambda.titlecase}}(
                                    parsedModel as {{#lambda.titlecase}}{{#PrimitiveInUnion}}{{{.}}}{{/PrimitiveInUnion}}{{/lambda.titlecase}},
                                );
                                break;
                        {{/oneOf}}
                        default:
                            throw UnsupportedError("Couldn't deserialize JSON: ${json}");
                    }
                    deserializedModels.add(deserializedModel);
                }
                // Throw an errpr when the incoming json parses into more than one models.
                if(deserializedModels.length > 1){
                    throw UnsupportedError("More than more one satisfied when parsing JSON: ${json}. Models: ${deserializedModels}");
                }
                if (deserializedModel == null) {
                    throw Exception("No models matched when parsing JSON: ${json}");
                }
                return deserializedModel;
            }
        {{/hasDiscriminatorWithNonEmptyMapping}}
    {{/vendorExtensions.x-is-child}}
{{/vendorExtensions.x-is-pure}}